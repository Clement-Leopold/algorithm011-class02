#学习笔记
## queue和priorityQueue : 分析
### Queue interface:
* boolean add： 成功返回 true， add方法不能添加空对象， 以及容器无空间则抛异常(这一点实现类有不同方案)；
* boolean offer: 成功返回true，如果空间不够则返回false， 不抛出异常；
* E remove: 取出头部元素， 队列为空则抛出 NPE 
* E poll:  取出头部元素，队列为空则返回null， 不抛出异常；
* E element: 获得头部元素, 为空则抛出异常；
* E peek: 获得头部元素，为空则返回null；
### priorityQueue:
1. PriorityQueue: java8为Class，内部包含一个Comparator; 默认小顶堆；
2. 实现方式为数组建堆；
3. 
    add方法实际调用为offer； 
    remove方法则跟poll有较大出入，remove方法有两个，跟数据位置有较大关系；
    简要说明就是插入删除都要重新调整堆。
4. 其主要私有函数为shiftUp，shiftDown, 即上浮和下沉函数；
5. 按照java 此版的实现， 插入和删除个人感觉应该都是O(logN),取队头为 O(1);
6. 针对第五点，冒昧提出一个问题，覃老师说的优先队列插入复杂度为 O(1),其实没太理解，是其他语言或者版本的实现方式不一样吗？

##总结
* 个人感悟:
    * 首先说一下本人的情况： 本人leetcode，也是完成了270道题左右，大部分题目完成了1-2遍；不过时间确实耗费很长；
    * 感悟了老师提出的学习方法，不要死磕；工作几年之后，确实死磕题目会耗费大量时间，投入产出比，不划算；
    * 如果只做1-2次，很多困难题目，确实很难快速写出代码；
* 代码：
    * 普通算法都是 if，loop， recursion， 这个总结很厉害， 但是recursion代码撰写难度还是有的，不能很快思考到正确的编写方式；
* 数据结构：
    * 本周的数据结构（都很重要，以至于无话可说）：
        * 数组(虽然现代java工程，大部分人不喜欢使用数组)，链表，跳表（使用的情况比较少，java中只看到ConcurrentSkipListMap）
        * 栈(LIFO)，队列(FIFO)，优先队列(top-k)，双端队列(栈的替代工程实现)
    * 以上数据结构无论是做题，还是工程，其实经常都会用到，必须学会分析源代码，才能更好理解何种场景运用何种数据结构；
* PS: 工作几年之后，越来越发现内功的重要性，java 中的Spring，虽然强大，但是并非解决了所有问题：
    * clean code；
    * 代码设计；
    * 特殊需求需要算法思维, CRUD 没法打天下；
    

   

